require("dotenv").config();
const ethers = require("ethers");
const hre = require("hardhat");
const { log } = require("console");
const { expect } = require("chai");
const { Helper } = require("./helper");
const { BlockHelper } = require("../scripts/utils/blockHelper");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");
const { Fixtures, testLog } = require("./fixture");

const domain = {
    name: "StakingClaim",
    version: "1",
    // chainId: 31337,
    // verifyingContract: stakingClaim.target,
};

describe("StakingClaim", () => {
    let contractAdmin,
        firstOwner,
        secondOwner,
        thirdOwner,
        user1,
        user2,
        user3,
        user4;
    let mockWUSD, stakingClaim;

    before(async () => {
        const { accounts, mockWUSDContract, stakingClaimContract } =
            await loadFixture(Fixtures.init);
        [
            contractAdmin,
            firstOwner,
            secondOwner,
            thirdOwner,
            user1,
            user2,
            user3,
            user4,
        ] = accounts;
        mockWUSD = mockWUSDContract;
        stakingClaim = stakingClaimContract;

        domain.verifyingContract = stakingClaim.target;
        domain.chainId = hre.network.config.chainId;
    });

    describe("Deployment", () => {
        it("Should revert if deployed with duplicate owners", async () => {
            const StakingClaimFactory =
                await hre.ethers.getContractFactory("StakingClaim");
            await expect(
                hre.upgrades.deployProxy(
                    StakingClaimFactory,
                    [
                        contractAdmin.address,
                        firstOwner.address,
                        firstOwner.address,
                        thirdOwner.address,
                    ],
                    { constructorArgs: [mockWUSD.target] },
                ),
            ).to.be.revertedWithCustomError(stakingClaim, "DuplicateSigner");
        });

        it("Should revert if deployed with MockWUSD address as zero", async () => {
            const StakingClaimFactory =
                await hre.ethers.getContractFactory("StakingClaim");
            await expect(
                hre.upgrades.deployProxy(
                    StakingClaimFactory,
                    [
                        contractAdmin.address,
                        firstOwner.address,
                        secondOwner.address,
                        thirdOwner.address,
                    ],
                    { constructorArgs: [ethers.ZeroAddress] },
                ),
            ).to.be.revertedWithCustomError(stakingClaim, "NoZeroAddress");
        });

        it("StakingClaim's Base token must be the MockWUSD address", async () => {
            expect(await stakingClaim.getBaseToken()).to.equal(mockWUSD.target);
        });

        it("Contract Admin account must have the DEFAULT_ADMIN_ROLE", async () => {
            expect(
                await stakingClaim.hasRole(
                    await stakingClaim.DEFAULT_ADMIN_ROLE(),
                    contractAdmin.address,
                ),
            ).to.be.true;
        });

        it("All owners have been setup", async () => {
            expect(await stakingClaim.getOwners()).to.deep.eq([
                firstOwner.address,
                secondOwner.address,
                thirdOwner.address,
            ]);
        });
    });

    describe("Signatures", () => {
        it("Sign and verify a Typed data message", async () => {
            const claimableTimestamp = 1725148800;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            const signature = await Helper.signTypedData(typedData, firstOwner);

            const digest = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            const recoveredAddress = ethers.recoverAddress(digest, signature);

            expect(
                (await stakingClaim.recoverSigners(digest, signature))[0],
            ).to.deep.eq(recoveredAddress);
        });

        it("Function call Digest should match with the one generated by ethers", async () => {
            const claimableTimestamp = 1725148800;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            const offchainDigest = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            expect(
                await stakingClaim.getEIP712FunctionCallDigest(
                    typedData.message.nonce,
                    typedData.message.selector,
                    typedData.message.inputData,
                ),
            ).to.deep.eq(offchainDigest);
        });

        it("Function call struct hash should match with the one generated by ethers", async () => {
            const claimableTimestamp = 1725148800;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            const offchainStructHash = ethers.TypedDataEncoder.hashStruct(
                typedData.primaryType,
                typedData.types,
                typedData.message,
            );

            expect(
                await stakingClaim.getEIP712FunctionCallStructHash(
                    typedData.message.nonce,
                    typedData.message.selector,
                    typedData.message.inputData,
                ),
            ).to.deep.eq(offchainStructHash);
        });

        it("Should recover signers from a combined-signature", async () => {
            const claimableTimestamp = 1725148800;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            const digest = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            const recoveredSigners = await stakingClaim.recoverSigners(
                digest,
                combinedSignatures,
            );

            expect(recoveredSigners).to.deep.eq([
                firstOwner.address,
                secondOwner.address,
                thirdOwner.address,
            ]);
        });

        it("Should revert with InvalidSignatureLength if signature length does not divide by 65", async () => {
            const invalidSignatures = ethers.randomBytes(66);
            const randomDigest = ethers.randomBytes(32);

            await expect(
                stakingClaim.recoverSigners(randomDigest, invalidSignatures),
            ).to.be.revertedWithCustomError(
                stakingClaim,
                "InvalidSignatureLength",
            );
        });

        it("Should revert with InvalidSignatureLength if signature length equals to 0", async () => {
            const invalidSignatures = ethers.randomBytes(0);
            const randomDigest = ethers.randomBytes(32);

            await expect(
                stakingClaim.recoverSigners(randomDigest, invalidSignatures),
            ).to.be.revertedWithCustomError(
                stakingClaim,
                "InvalidSignatureLength",
            );
        });
    });

    describe("Execution", () => {
        it("Should revert without a reason if executed with an invalid selector", async () => {
            const invalidSelector = ethers.hexlify(ethers.randomBytes(4));
            const inputData = ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address"],
                [firstOwner.address, ethers.Wallet.createRandom().address],
            );
            const nonce = await stakingClaim.getNonce(invalidSelector);
            const payload = { nonce, selector: invalidSelector, inputData };

            const typedData = Helper.getTypedData(
                domain,
                Helper.FunctionCallType,
                Object.keys(Helper.FunctionCallType)[0],
                payload,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(invalidSelector, inputData, combinedSignatures),
            ).to.be.revertedWithoutReason();
        });

        it("Should revert with no reason if executed with an invalid input data", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            // generate invalid input data
            typedData.message.inputData =
                ethers.AbiCoder.defaultAbiCoder().encode(
                    ["address", "address"],
                    [firstOwner.address, ethers.Wallet.createRandom().address],
                );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            ).to.be.revertedWithoutReason();
        });
    });

    describe("Create Claim Data", () => {
        it("Should revert with ExecutionForbidden if createClaimData is called directly by a non-owner", async () => {
            const claimer = user1.address;
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);
            const accessKey = ethers.solidityPackedKeccak256(
                ["address", "uint48", "uint256"],
                [claimer, claimableTimestamp, claimAmount],
            );

            await expect(
                stakingClaim
                    .connect(user1)
                    .createClaimData(
                        claimer,
                        claimableTimestamp,
                        claimAmount,
                        accessKey,
                    ),
            ).to.be.revertedWithCustomError(stakingClaim, "ExecutionForbidden");
        });

        it("Should revert with ExecutionForbidden if createClaimData is called directly by an owner", async () => {
            const claimer = user1.address;
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);
            const accessKey = ethers.solidityPackedKeccak256(
                ["address", "uint48", "uint256"],
                [claimer, claimableTimestamp, claimAmount],
            );

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .createClaimData(
                        claimer,
                        claimableTimestamp,
                        claimAmount,
                        accessKey,
                    ),
            ).to.be.revertedWithCustomError(stakingClaim, "ExecutionForbidden");
        });

        it("Should revert with CallerIsNotOwner if executed by a non-owner", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(user1)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.be.revertedWithCustomError(stakingClaim, "CallerIsNotOwner")
                .withArgs(user1.address);
        });

        it("Should revert with UnauthorizedSigner if executed with invalid signatures", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                user1,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.be.revertedWithCustomError(
                    stakingClaim,
                    "UnauthorizedSigner",
                )
                .withArgs(user1.address);
        });

        it("Should revert with UnauthorizedSigner if signature is reused", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            let digest1 = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            testLog("Digest with valid nonce:", digest1);

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await stakingClaim
                .connect(firstOwner)
                .execute(
                    typedData.message.selector,
                    typedData.message.inputData,
                    combinedSignatures,
                );

            typedData.message.nonce++;

            let digest2 = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            testLog("Invalid digest after nonce increased:", digest2);

            const expectedInvalidSigner = ethers.recoverAddress(
                digest2,
                signatures[0],
            );
            testLog(
                "Expected invalid signer recovered from invalid digest:",
                expectedInvalidSigner,
            );

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.be.revertedWithCustomError(
                    stakingClaim,
                    "UnauthorizedSigner",
                )
                .withArgs(expectedInvalidSigner);
        });

        it("Should revert with OverwritingClaim if claim data already exists", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            let signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            let combinedSignatures = ethers.concat(signatures);

            await stakingClaim
                .connect(firstOwner)
                .execute(
                    typedData.message.selector,
                    typedData.message.inputData,
                    combinedSignatures,
                );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.be.revertedWithCustomError(stakingClaim, "OverwritingClaim")
                .withArgs(user1.address, accessKey);
        });

        it("Should revert with DuplicateSigner if the same signer signs twice", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [_, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            let signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                firstOwner,
                thirdOwner,
            ]);

            let combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            ).to.be.revertedWithCustomError(stakingClaim, "DuplicateSigner");

            signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                firstOwner,
            ]);

            combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            ).to.be.revertedWithCustomError(stakingClaim, "DuplicateSigner");
        });

        it("Should revert with InvalidAccessKey if createClaimData is called with an invalid access key", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);
            const claimer = user1.address;

            const invalidAccessKey = ethers.solidityPackedKeccak256(
                ["address", "uint48", "uint256"],
                [
                    ethers.Wallet.createRandom().address,
                    claimableTimestamp,
                    claimAmount,
                ],
            );

            const inputDataWithInvalidAccessKey =
                ethers.AbiCoder.defaultAbiCoder().encode(
                    ["address", "uint48", "uint256", "bytes32"],
                    [
                        claimer,
                        claimableTimestamp,
                        claimAmount,
                        invalidAccessKey,
                    ],
                );

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                claimer,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            typedData.message.inputData = inputDataWithInvalidAccessKey;

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.be.revertedWithCustomError(stakingClaim, "InvalidAccessKey")
                .withArgs(invalidAccessKey, accessKey);
        });

        it("Should successfully create Claim Data for user1", async () => {
            const claimableTimestamp = Date.now() + 1000;
            const claimAmount = ethers.parseUnits("1000", 6);

            const [accessKey, typedData] = await Fixtures.createClaimData(
                domain,
                user1.address,
                claimableTimestamp,
                claimAmount,
            );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            testLog({ accessKey });
            testLog(typedData);

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            testLog({ signatures });
            testLog({ combinedSignatures });

            expect(await stakingClaim.isOwner(firstOwner.address)).to.be.true;
            expect(await stakingClaim.isOwner(secondOwner.address)).to.be.true;
            expect(await stakingClaim.isOwner(thirdOwner.address)).to.be.true;

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.emit(stakingClaim, "ClaimDataCreated")
                .withArgs(
                    user1.address,
                    claimableTimestamp,
                    claimAmount,
                    accessKey,
                );

            const claimDataByUser = await stakingClaim.getClaimData(
                user1.address,
                accessKey,
            );

            expect(claimDataByUser).to.deep.eq([claimAmount, 0]);
        });
    });

    describe("Create Claim Data Multiple", () => {
        it("Should revert with ExecutionForbidden if createClaimDataMultiple is called directly by a non-owner", async () => {
            const claimers = [
                user1.address,
                user2.address,
                user3.address,
                user4.address,
            ];
            const claimableTimestamps = [
                Date.now() + 1000,
                Date.now() + 2000,
                Date.now() + 3000,
                Date.now() + 4000,
            ];
            const claimAmounts = [
                ethers.parseUnits("1000", 6),
                ethers.parseUnits("2000", 6),
                ethers.parseUnits("3000", 6),
                ethers.parseUnits("4000", 6),
            ];

            const [_, claimDataMultiple] = Fixtures.generateClaimDataList(
                claimers,
                claimableTimestamps,
                claimAmounts,
            );

            await expect(
                stakingClaim
                    .connect(user1)
                    .createClaimDataMultiple(claimDataMultiple),
            ).to.be.revertedWithCustomError(stakingClaim, "ExecutionForbidden");
        });

        it("Should revert with ExecutionForbidden if createClaimDataMultiple is called directly by an owner", async () => {
            const claimers = [
                user1.address,
                user2.address,
                user3.address,
                user4.address,
            ];
            const claimableTimestamps = [
                Date.now() + 1000,
                Date.now() + 2000,
                Date.now() + 3000,
                Date.now() + 4000,
            ];
            const claimAmounts = [
                ethers.parseUnits("1000", 6),
                ethers.parseUnits("2000", 6),
                ethers.parseUnits("3000", 6),
                ethers.parseUnits("4000", 6),
            ];

            const [_, claimDataMultiple] = Fixtures.generateClaimDataList(
                claimers,
                claimableTimestamps,
                claimAmounts,
            );

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .createClaimDataMultiple(claimDataMultiple),
            ).to.be.revertedWithCustomError(stakingClaim, "ExecutionForbidden");
        });

        it("Should successfully create Claim Data Multiple for 1 user", async () => {
            const claimers = [user1.address];
            const claimableTimestamps = [Date.now() + 1000];
            const claimAmounts = [ethers.parseUnits("1000", 6)];

            const [accessKeys, typedData] =
                await Fixtures.createClaimDataMultiple(
                    domain,
                    claimers,
                    claimableTimestamps,
                    claimAmounts,
                );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            testLog({ accessKeys });
            testLog({ typedData });

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.emit(stakingClaim, "ClaimDataCreated")
                .withArgs(
                    user1.address,
                    claimableTimestamps[0],
                    claimAmounts[0],
                    accessKeys[0],
                );
        });

        it("Should successfully create Claim Data Multiple for 4 users", async () => {
            const claimers = [
                user1.address,
                user2.address,
                user3.address,
                user4.address,
            ];
            const claimableTimestamps = [
                Date.now() + 1000,
                Date.now() + 2000,
                Date.now() + 3000,
                Date.now() + 4000,
            ];
            const claimAmounts = [
                ethers.parseUnits("1000", 6),
                ethers.parseUnits("2000", 6),
                ethers.parseUnits("3000", 6),
                ethers.parseUnits("4000", 6),
            ];

            const [accessKeys, typedData] =
                await Fixtures.createClaimDataMultiple(
                    domain,
                    claimers,
                    claimableTimestamps,
                    claimAmounts,
                );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            testLog({ accessKeys });
            testLog({ typedData });

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.emit(stakingClaim, "ClaimDataCreated")
                .withArgs(
                    user1.address,
                    claimableTimestamps[0],
                    claimAmounts[0],
                    accessKeys[0],
                )
                .and.to.emit(stakingClaim, "ClaimDataCreated")
                .withArgs(
                    user2.address,
                    claimableTimestamps[1],
                    claimAmounts[1],
                    accessKeys[1],
                )
                .and.to.emit(stakingClaim, "ClaimDataCreated")
                .withArgs(
                    user3.address,
                    claimableTimestamps[2],
                    claimAmounts[2],
                    accessKeys[2],
                )
                .and.to.emit(stakingClaim, "ClaimDataCreated")
                .withArgs(
                    user4.address,
                    claimableTimestamps[3],
                    claimAmounts[3],
                    accessKeys[3],
                );
        });

        it("Should successfully create Claim Data for 10 users", async () => {
            const [claimers, claimableTimestamps, claimAmounts] =
                Fixtures.generateClaimData(10);

            const [accessKeys, typedData] =
                await Fixtures.createClaimDataMultiple(
                    domain,
                    claimers,
                    claimableTimestamps,
                    claimAmounts,
                );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            testLog({ accessKeys });
            testLog({ typedData });

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            let txn = await stakingClaim
                .connect(firstOwner)
                .execute(
                    typedData.message.selector,
                    typedData.message.inputData,
                    combinedSignatures,
                );

            await txn.wait();

            const events = await stakingClaim.queryFilter(
                "ClaimDataCreated",
                txn.blockNumber,
                txn.blockNumber,
            );

            expect(events.length).to.equal(10);
        });

        it("Should successfully create Claim Data for 100 users", async () => {
            const [claimers, claimableTimestamps, claimAmounts] =
                Fixtures.generateClaimData(100);

            const [accessKeys, typedData] =
                await Fixtures.createClaimDataMultiple(
                    domain,
                    claimers,
                    claimableTimestamps,
                    claimAmounts,
                );

            typedData.message.nonce = await stakingClaim.getNonce(
                typedData.message.selector,
            );

            testLog({ accessKeys });
            testLog({ typedData });

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            let txn = await stakingClaim
                .connect(firstOwner)
                .execute(
                    typedData.message.selector,
                    typedData.message.inputData,
                    combinedSignatures,
                );

            await txn.wait();

            const events = await stakingClaim.queryFilter(
                "ClaimDataCreated",
                txn.blockNumber,
                txn.blockNumber,
            );

            expect(events.length).to.equal(100);
        });
    });

    describe("Change Owner", () => {
        it("Should revert with ExecutionForbidden if changeOwner is called directly by a non-owner", async () => {
            await expect(
                stakingClaim
                    .connect(user1)
                    .changeOwner(firstOwner.address, user1.address),
            ).to.be.revertedWithCustomError(stakingClaim, "ExecutionForbidden");
        });

        it("Should revert with ExecutionForbidden if changeOwner is called directly by an owner", async () => {
            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .changeOwner(firstOwner.address, user1.address),
            ).to.be.revertedWithCustomError(stakingClaim, "ExecutionForbidden");
        });

        it("Should revert with CallerIsNotOwner if executed by a non-owner", async () => {
            await expect(
                stakingClaim
                    .connect(user1)
                    .execute(
                        stakingClaim.interface.getFunction("changeOwner")
                            .selector,
                        ethers.AbiCoder.defaultAbiCoder().encode(
                            ["address", "address"],
                            [firstOwner.address, user1.address],
                        ),
                        ethers.randomBytes(65),
                    ),
            )
                .to.be.revertedWithCustomError(stakingClaim, "CallerIsNotOwner")
                .withArgs(user1.address);
        });

        it("Should revert with NotAnOwner if the old owner is not an owner", async () => {
            const newOwner = ethers.Wallet.createRandom().address;
            const invalidOwner = ethers.Wallet.createRandom().address;
            const selector =
                stakingClaim.interface.getFunction("changeOwner").selector;
            const inputData = ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address"],
                [invalidOwner, newOwner],
            );
            const nonce = await stakingClaim.getNonce(selector);
            const payload = { nonce, selector, inputData };

            const typedData = Helper.getTypedData(
                domain,
                Helper.FunctionCallType,
                Object.keys(Helper.FunctionCallType)[0],
                payload,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(selector, inputData, combinedSignatures),
            )
                .to.be.revertedWithCustomError(stakingClaim, "NotAnOwner")
                .withArgs(invalidOwner);
        });

        it("Should revert with UnauthorizedSigner if executed with invalid signatures", async () => {
            const newOwner = ethers.Wallet.createRandom().address;
            const selector =
                stakingClaim.interface.getFunction("changeOwner").selector;
            const inputData = ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address"],
                [firstOwner.address, newOwner],
            );
            const nonce = await stakingClaim.getNonce(selector);
            const payload = { nonce, selector, inputData };

            const typedData = Helper.getTypedData(
                domain,
                Helper.FunctionCallType,
                Object.keys(Helper.FunctionCallType)[0],
                payload,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                user1,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(selector, inputData, combinedSignatures),
            )
                .to.be.revertedWithCustomError(
                    stakingClaim,
                    "UnauthorizedSigner",
                )
                .withArgs(user1.address);
        });

        it("Should revert with UnauthorizedSigner if signature is reused", async () => {
            const { accounts, stakingClaimContract: stakingClaim } =
                await loadFixture(Fixtures.init);
            [
                contractAdmin,
                firstOwner,
                secondOwner,
                thirdOwner,
                user1,
                user2,
                user3,
                user4,
            ] = accounts;

            domain.verifyingContract = stakingClaim.target;

            const newOwner = user1.address;
            const selector =
                stakingClaim.interface.getFunction("changeOwner").selector;
            const inputData = ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address"],
                [firstOwner.address, newOwner],
            );
            const nonce = await stakingClaim.getNonce(selector);
            const payload = { nonce, selector, inputData };

            const typedData = Helper.getTypedData(
                domain,
                Helper.FunctionCallType,
                Object.keys(Helper.FunctionCallType)[0],
                payload,
            );

            let digest1 = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            testLog("Digest with valid nonce:", digest1);

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                secondOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await stakingClaim
                .connect(firstOwner)
                .execute(
                    typedData.message.selector,
                    typedData.message.inputData,
                    combinedSignatures,
                );

            typedData.message.nonce++;

            let digest2 = ethers.TypedDataEncoder.hash(
                typedData.domain,
                typedData.types,
                typedData.message,
            );

            testLog("Invalid digest after nonce increased:", digest2);

            const expectedInvalidSigner = ethers.recoverAddress(
                digest2,
                signatures[0],
            );
            testLog(
                "Expected invalid signer recovered from invalid digest:",
                expectedInvalidSigner,
            );

            await expect(
                stakingClaim
                    .connect(user1)
                    .execute(
                        typedData.message.selector,
                        typedData.message.inputData,
                        combinedSignatures,
                    ),
            )
                .to.be.revertedWithCustomError(
                    stakingClaim,
                    "UnauthorizedSigner",
                )
                .withArgs(expectedInvalidSigner);
        });

        it("Should revert with DuplicateSigner if the same signer signs twice", async () => {
            const { accounts, stakingClaimContract: stakingClaim } =
                await loadFixture(Fixtures.init);
            [
                contractAdmin,
                firstOwner,
                secondOwner,
                thirdOwner,
                user1,
                user2,
                user3,
                user4,
            ] = accounts;

            domain.verifyingContract = stakingClaim.target;

            const newOwner = ethers.Wallet.createRandom().address;
            const selector =
                stakingClaim.interface.getFunction("changeOwner").selector;
            const inputData = ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address"],
                [firstOwner.address, newOwner],
            );
            const nonce = await stakingClaim.getNonce(selector);
            const payload = { nonce, selector, inputData };

            expect(await stakingClaim.isOwner(firstOwner.address)).to.be.true;

            const typedData = Helper.getTypedData(
                domain,
                Helper.FunctionCallType,
                Object.keys(Helper.FunctionCallType)[0],
                payload,
            );

            const signatures = await Helper.signTypedDataMultiple(typedData, [
                firstOwner,
                firstOwner,
                thirdOwner,
            ]);

            const combinedSignatures = ethers.concat(signatures);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(selector, inputData, combinedSignatures),
            ).to.be.revertedWithCustomError(stakingClaim, "DuplicateSigner");

            const newOwner2 = ethers.Wallet.createRandom().address;
            const selector2 =
                stakingClaim.interface.getFunction("changeOwner").selector;
            const inputData2 = ethers.AbiCoder.defaultAbiCoder().encode(
                ["address", "address"],
                [firstOwner.address, newOwner2],
            );
            const nonce2 = await stakingClaim.getNonce(selector2);
            const payload2 = {
                nonce: nonce2,
                selector: selector2,
                inputData: inputData2,
            };

            const typedData2 = Helper.getTypedData(
                domain,
                Helper.FunctionCallType,
                Object.keys(Helper.FunctionCallType)[0],
                payload2,
            );

            const signatures2 = await Helper.signTypedDataMultiple(typedData2, [
                firstOwner,
                secondOwner,
                firstOwner,
            ]);

            const combinedSignatures2 = ethers.concat(signatures2);

            await expect(
                stakingClaim
                    .connect(firstOwner)
                    .execute(selector2, inputData2, combinedSignatures2),
            ).to.be.revertedWithCustomError(stakingClaim, "DuplicateSigner");
        });
    });
});
